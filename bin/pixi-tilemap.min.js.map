{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/CanvasTileRenderer.js","pixi-tilemap.min.js","src/CompositeRectTileLayer.js","src/GraphicsLayer.js","src/RectTileLayer.js","src/RectTileShader.js","src/SquareTileShader.js","src/TileRenderer.js","src/ZLayer.js","src/index","src/shaderGenerator.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","CanvasTileRenderer","renderer","this","tileAnim","PIXI","CanvasRenderer","registerPlugin","2","CompositeRectTileLayer","Container","apply","arguments","initialize","RectTileLayer","prototype","Object","create","constructor","updateTransform","displayObjectUpdateTransform","zIndex","bitmaps","useSquare","z","shadowColor","Float32Array","setBitmaps","removeChildren","addChild","modificationMarker","clear","children","addRect","num","v","x","y","tileWidth","tileHeight","textures","addFrame","texture","Texture","fromImage","layer","ind","tex","j","baseTexture","child","push","frame","width","height","renderCanvas","dontUseTransform","wt","worldTransform","context","setTransform","b","c","d","tx","resolution","ty","layers","renderWebGL","shader","gl","plugins","tile","getShader","setObjectRenderer","bindShader","_globalMat","Matrix","_activeRenderTarget","projectionMatrix","copy","append","uniforms","toArray","tempScale","_tempScale","pointScale","projectionScale","Math","abs","animationFrame","isModified","anim","pointsBuf","hasAnim","clearModify","./RectTileLayer","3","GraphicsLayer","Graphics","transform","IDENTITY","graphics","render","globalAlpha","_webGL","id","dirty","4","DisplayObject","Array","visible","_tempSize","_tempTexSize","points","fillStyle","x1","y1","x2","y2","w","h","textureId","drawImage","source","fillRect","animX","animY","pb","len","maxTextures","valid","bindTextures","vb","getVb","vbId","createVb","vbBuffer","vao","bind","vertices","vertPerQuad","vs","stride","byteLength","bk","ArrayBuffer","vbArray","vbInts","Uint32Array","upload","shiftU","shiftV","arr","sz","drawArrays","POINTS","TRIANGLES","5","RectTileShader","Shader","shaderGenerator","generateFragmentSrc","vertSize","fillSamplers","createVao","addIndex","indexBuffer","addAttribute","attributes","aVertexPosition","FLOAT","aTextureCoord","aAnim","aTextureId","./shaderGenerator","6","SquareTileShader","aSize","7","TileRenderer","ObjectRenderer","vbs","lastTimeCheck","indices","Uint16Array","glCore","vbAutoincrement","onContextChange","rectShader","squareShader","GLBuffer","createIndexBuffer","STATIC_DRAW","glTextures","boundSprites","initBounds","tempCanvas","document","createElement","glt","GLTexture","premultiplyAlpha","enableWrapClamp","enableLinearScaling","bs","spr","Sprite","position","_hackSubImage","sprite","baseTex","texSubImage2D","TEXTURE_2D","format","type","bounds","glts","bindTexture","_activeTextureLocation","checkLeaks","now","Date","old","key","lastTimeAccess","removeVb","start","state","setBlendMode","BLEND_MODES","NORMAL","lastAccessTime","createVertexBuffer","STREAM_DRAW","stuff","destroy","WebGLRenderer","./RectTileShader","./SquareTileShader","8","ZLayer","tilemap","_previousLayers","cacheIfDirty","modified","buf","canvasBuffer","tempRender","_tempRender","view","rootContext","_layerWidth","_layerHeight","_lastAnimationFrame","_hackRenderer","clearRect","layerTransform","9","./CanvasTileRenderer","./CompositeRectTileLayer","./GraphicsLayer","./TileRenderer","./ZLayer","10","sampleValues","uSamplers","samplerSize","uSamplerSize","fragmentSrc","replace","generateSampleSrc","src"],"mappings":"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","file":"pixi-tilemap.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","function CanvasTileRenderer(renderer) {\n    this.renderer = renderer;\n    this.tileAnim = [0, 0];\n}\n\nPIXI.CanvasRenderer.registerPlugin('tile', CanvasTileRenderer);\n\nmodule.exports = CanvasTileRenderer;\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction CanvasTileRenderer(renderer) {\n    this.renderer = renderer;\n    this.tileAnim = [0, 0];\n}\n\nPIXI.CanvasRenderer.registerPlugin('tile', CanvasTileRenderer);\n\nmodule.exports = CanvasTileRenderer;\n\n},{}],2:[function(require,module,exports){\nvar RectTileLayer = require('./RectTileLayer');\n\nfunction CompositeRectTileLayer() {\n    PIXI.Container.apply(this, arguments);\n    this.initialize.apply(this, arguments);\n}\n\nCompositeRectTileLayer.prototype = Object.create(PIXI.Container.prototype);\nCompositeRectTileLayer.prototype.constructor = RectTileLayer;\nCompositeRectTileLayer.prototype.updateTransform = CompositeRectTileLayer.prototype.displayObjectUpdateTransform;\n\n//can be initialized multiple times\nCompositeRectTileLayer.prototype.initialize = function(zIndex, bitmaps, useSquare) {\n    this.z = this.zIndex = zIndex;\n    this.useSquare = useSquare;\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    if (bitmaps) {\n        this.setBitmaps(bitmaps);\n    }\n};\n\nCompositeRectTileLayer.prototype.setBitmaps = function(bitmaps) {\n    this.removeChildren();\n    this.addChild(new RectTileLayer(this.zIndex, bitmaps));\n    this.modificationMarker = 0;\n};\n\nCompositeRectTileLayer.prototype.clear = function () {\n    for (var i=0;i<this.children.length;i++)\n        this.children[i].clear();\n    this.modificationMarker = 0;\n};\n\nCompositeRectTileLayer.prototype.addRect = function (num, u, v, x, y, tileWidth, tileHeight) {\n    if (this.children[num] && this.children[num].textures)\n        this.children[num].addRect(0, u, v, x, y, tileWidth, tileHeight);\n};\n\n/**\n * \"hello world!\" of pixi-tilemap library. Pass it texture and it will be added\n * @param texture\n * @param x\n * @param y\n * @returns {boolean}\n */\nCompositeRectTileLayer.prototype.addFrame = function (texture, x, y) {\n    if (typeof texture === \"string\") {\n        texture = PIXI.Texture.fromImage(texture);\n    }\n    var children = this.children;\n    var layer = null, ind = 0;\n    for (var i=0;i<children.length; i++) {\n        var tex = children[i].textures;\n        for (var j=0;j < tex.length;j++) {\n            if (tex[j].baseTexture == texture.baseTexture) {\n                layer = children[i];\n                ind = j;\n                break;\n            }\n        }\n        if (layer) {\n            break;\n        }\n    }\n    if (!layer) {\n        for (i=0;i<children.length;i++) {\n            var child = children[i];\n            if (child.textures.length < 16) {\n                layer = child;\n                ind = child.textures.length;\n                child.textures.push(texture);\n            }\n        }\n        if (!layer) {\n            children.push(layer = new RectTileLayer(this.zIndex, texture));\n            ind = 0;\n        }\n    }\n    layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.frame.width, texture.frame.height);\n    return true;\n};\n\nCompositeRectTileLayer.prototype.renderCanvas = function (renderer) {\n    if (!renderer.dontUseTransform) {\n        var wt = this.worldTransform;\n        renderer.context.setTransform(\n            wt.a,\n            wt.b,\n            wt.c,\n            wt.d,\n            wt.tx * renderer.resolution,\n            wt.ty * renderer.resolution\n        );\n    }\n    var layers = this.children;\n    for (var i = 0; i < layers.length; i++)\n        layers[i].renderCanvas(renderer);\n};\n\n\nCompositeRectTileLayer.prototype.renderWebGL = function(renderer) {\n    var gl = renderer.gl;\n    var shader = renderer.plugins.tile.getShader(this.useSquare);\n    renderer.setObjectRenderer(renderer.plugins.tile);\n    renderer.bindShader(shader);\n    //TODO: dont create new array, please\n    this._globalMat = this._globalMat || new PIXI.Matrix();\n    renderer._activeRenderTarget.projectionMatrix.copy(this._globalMat).append(this.worldTransform);\n    shader.uniforms.projectionMatrix = this._globalMat.toArray(true);\n    shader.uniforms.shadowColor = this.shadowColor;\n    if (this.useSquare) {\n        var tempScale = this._tempScale = (this._tempScale || [0, 0]);\n        tempScale[0] = this._globalMat.a >= 0?1:-1;\n        tempScale[1] = this._globalMat.d < 0?1:-1;\n        var ps = shader.uniforms.pointScale = tempScale;\n        shader.uniforms.projectionScale = Math.abs(this.worldTransform.a) * renderer.resolution;\n    }\n    var af = shader.uniforms.animationFrame = renderer.plugins.tile.tileAnim;\n    //shader.syncUniform(shader.uniforms.animationFrame);\n    var layers = this.children;\n    for (var i = 0; i < layers.length; i++)\n        layers[i].renderWebGL(renderer, this.useSquare);\n};\n\n\nCompositeRectTileLayer.prototype.isModified = function(anim) {\n    var layers = this.children;\n    if (this.modificationMarker != layers.length) {\n        return true;\n    }\n    for (var i=0;i<layers.length;i++) {\n        if (layers[i].modificationMarker != layers[i].pointsBuf.length ||\n            anim && layers[i].hasAnim) {\n            return true;\n        }\n    }\n    return false;\n};\n\nCompositeRectTileLayer.prototype.clearModify = function() {\n    var layers = this.children;\n    this.modificationMarker = layers.length;\n    for (var i = 0; i < layers.length; i++) {\n        layers[i].modificationMarker = layers[i].pointsBuf.length;\n    }\n};\n\nmodule.exports = CompositeRectTileLayer;\n\n},{\"./RectTileLayer\":4}],3:[function(require,module,exports){\nfunction GraphicsLayer(zIndex) {\n    PIXI.Graphics.apply(this, arguments);\n    this.z = this.zIndex = zIndex;\n}\n\nGraphicsLayer.prototype = Object.create(PIXI.Graphics.prototype);\nGraphicsLayer.prototype.constructor = GraphicsLayer;\nGraphicsLayer.prototype.renderCanvas = function (renderer) {\n    var wt = null;\n    if (renderer.dontUseTransform) {\n        wt = this.transform.worldTransform;\n        this.transform.worldTransform = PIXI.Matrix.IDENTITY;\n    }\n    renderer.plugins.graphics.render(this);\n    if (renderer.dontUseTransform) {\n        this.transform.worldTransform = wt;\n    }\n    renderer.context.globalAlpha = 1.0;\n};\nGraphicsLayer.prototype.renderWebGL = function(renderer) {\n    if (!this._webGL[renderer.gl.id])\n        this.dirty = true;\n    PIXI.Graphics.prototype.renderWebGL.call(this, renderer);\n};\n\nGraphicsLayer.prototype.isModified = function(anim) {\n    return false;\n};\n\nGraphicsLayer.prototype.clearModify = function() {\n};\n\nmodule.exports = GraphicsLayer;\n\n},{}],4:[function(require,module,exports){\nfunction RectTileLayer(zIndex, texture) {\n    PIXI.DisplayObject.apply(this, arguments);\n    this.initialize.apply(this, arguments);\n}\n\nRectTileLayer.prototype = Object.create(PIXI.DisplayObject.prototype);\nRectTileLayer.prototype.constructor = RectTileLayer;\n\nRectTileLayer.prototype.initialize = function(zIndex, textures) {\n    if (!textures) {\n        textures = [];\n    } else if (!(textures instanceof Array) && textures.baseTexture) {\n        textures = [textures];\n    }\n    this.textures = textures;\n    this.z = this.zIndex = zIndex;\n    this.pointsBuf = [];\n    this.visible = false;\n    this._tempSize = new Float32Array([0, 0]);\n    this._tempTexSize = 1;\n};\n\nRectTileLayer.prototype.clear = function () {\n    this.pointsBuf.length = 0;\n    this.modificationMarker = 0;\n    this.hasAnim = false;\n};\n\nRectTileLayer.prototype.renderCanvas = function (renderer) {\n    if (this.textures.length === 0) return;\n    var points = this.pointsBuf;\n    renderer.context.fillStyle = '#000000';\n    for (var i = 0, n = points.length; i < n; i += 9) {\n        var x1 = points[i], y1 = points[i+1];\n        var x2 = points[i+2], y2 = points[i+3];\n        var w = points[i+4];\n        var h = points[i+5];\n        x1 += points[i+6] * renderer.plugins.tile.tileAnim[0];\n        y1 += points[i+7] * renderer.plugins.tile.tileAnim[1];\n        var textureId = points[i+8];\n        if (textureId >= 0) {\n            renderer.context.drawImage(this.textures[textureId].baseTexture.source, x1, y1, w, h, x2, y2, w, h);\n        } else {\n            renderer.context.globalAlpha = 0.5;\n            renderer.context.fillRect(x2, y2, w, h);\n            renderer.context.globalAlpha = 1;\n        }\n    }\n};\n\nRectTileLayer.prototype.addRect = function (textureId, u, v, x, y, tileWidth, tileHeight, animX, animY) {\n    var pb = this.pointsBuf;\n    this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\n    if (tileWidth == tileHeight) {\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureId);\n    } else {\n        var i;\n        if (tileWidth % tileHeight === 0) {\n            //horizontal line on squares\n            for (i=0;i<tileWidth/tileHeight;i++) {\n                pb.push(u + i * tileHeight);\n                pb.push(v);\n                pb.push(x + i * tileHeight);\n                pb.push(y);\n                pb.push(tileHeight);\n                pb.push(tileHeight);\n                pb.push(animX | 0);\n                pb.push(animY | 0);\n                pb.push(textureId);\n            }\n        } else if (tileHeight % tileWidth === 0) {\n            //vertical line on squares\n            for (i=0;i<tileHeight/tileWidth;i++) {\n                pb.push(u);\n                pb.push(v + i * tileWidth);\n                pb.push(x);\n                pb.push(y + i * tileWidth);\n                pb.push(tileWidth);\n                pb.push(tileWidth);\n                pb.push(animX | 0);\n                pb.push(animY | 0);\n                pb.push(textureId);\n            }\n        } else {\n            //ok, ok, lets use rectangle. but its not working with square shader yet\n            pb.push(u);\n            pb.push(v);\n            pb.push(x);\n            pb.push(y);\n            pb.push(tileWidth);\n            pb.push(tileHeight);\n            pb.push(animX | 0);\n            pb.push(animY | 0);\n            pb.push(textureId);\n        }\n    }\n};\n\nRectTileLayer.prototype.renderWebGL = function(renderer, useSquare) {\n    var points = this.pointsBuf;\n    if (points.length === 0) return;\n\n    var tile = renderer.plugins.tile;\n    var gl = renderer.gl;\n    var shader = tile.getShader(useSquare);\n    var textures = this.textures;\n    if (textures.length === 0) return;\n    var len = textures.length;\n    if (this._tempTexSize < shader.maxTextures) {\n        this._tempTexSize = shader.maxTextures;\n        this._tempSize = new Float32Array(2*shader.maxTextures);\n    }\n    // var samplerSize = this._tempSize;\n    for (var i=0;i<len;i++) {\n        if (!textures[i] || !textures[i].valid) return;\n        var texture = textures[i].baseTexture;\n        // samplerSize[i * 2] = 1.0 / texture.width;\n        // samplerSize[i * 2 + 1] = 1.0 / texture.height;\n    }\n    tile.bindTextures(renderer, textures);\n    // shader.uniforms.uSamplerSize = samplerSize;\n    //lost context! recover!\n    var vb = tile.getVb(this.vbId);\n    if (!vb) {\n        vb = tile.createVb(useSquare);\n        this.vbId = vb.id;\n        this.vbBuffer = null;\n        this.modificationMarker = 0;\n    }\n    var vao = vb.vao.bind();\n    vb = vb.vb;\n    //if layer was changed, re-upload vertices\n    vb.bind();\n    var vertices = points.length / 9 * shader.vertPerQuad;\n    if (this.modificationMarker != vertices) {\n        this.modificationMarker = vertices;\n        var vs = shader.stride * vertices;\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n            //!@#$ happens, need resize\n            var bk = shader.stride;\n            while (bk < vs) {\n                bk *= 2;\n            }\n            this.vbBuffer = new ArrayBuffer(bk);\n            this.vbArray = new Float32Array(this.vbBuffer);\n            this.vbInts = new Uint32Array(this.vbBuffer);\n            vb.upload(this.vbBuffer, 0, true);\n        }\n\n        var arr = this.vbArray, ints = this.vbInts;\n        //upload vertices!\n        var sz = 0;\n        //var tint = 0xffffffff;\n        var textureId, shiftU, shiftV;\n        if (useSquare) {\n            for (i = 0; i < points.length; i += 9) {\n                textureId = (points[i+8] >> 2);\n                shiftU = 1024 * (points[i+8] & 1);\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\n                arr[sz++] = points[i + 2];\n                arr[sz++] = points[i + 3];\n                arr[sz++] = points[i + 0] + shiftU;\n                arr[sz++] = points[i + 1] + shiftV;\n                arr[sz++] = points[i + 4];\n                arr[sz++] = points[i + 6];\n                arr[sz++] = points[i + 7];\n                arr[sz++] = textureId;\n            }\n        } else {\n            //var tint = 0xffffffff;\n            var tint = -1;\n            for (i = 0;i<points.length;i += 9) {\n                textureId = (points[i+8] >> 2);\n                shiftU = 1024 * (points[i+8] & 1);\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\n                var x = points[i+2], y = points[i+3];\n                var w = points[i+4], h = points[i+5];\n                var u = points[i] + shiftU, v = points[i+1] + shiftV;\n                var animX = points[i+6], animY = points[i+7];\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u + w;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u + w;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u + w;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n            }\n        }\n        // if (vs > this.vbArray.length/2 ) {\n        vb.upload(arr, 0, true);\n        // } else {\n        //     var view = arr.subarray(0, vs);\n        //     vb.upload(view, 0);\n        // }\n    }\n    if (useSquare)\n        gl.drawArrays(gl.POINTS, 0, vertices);\n    else\n        gl.drawArrays(gl.TRIANGLES, 0, vertices);\n};\n\nmodule.exports = RectTileLayer;\n\n},{}],5:[function(require,module,exports){\nvar shaderGenerator = require('./shaderGenerator');\n\nfunction RectTileShader(gl, maxTextures)\n{\n    PIXI.Shader.call(this, gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec2 aAnim;\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\nuniform vec2 animationFrame;\\n\\nvarying vec2 vTextureCoord;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n   vTextureId = aTextureId;\\n}\\n\",\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying float vTextureId;\\nuniform vec4 shadowColor;\\nuniform sampler2D uSamplers[%count%];\\nuniform vec2 uSamplerSize[%count%];\\n\\nvoid main(void){\\n   vec2 textureCoord = vTextureCoord;\\n   vec4 color;\\n   %forloop%\\n   gl_FragColor = color;\\n}\\n\")\n    );\n    this.maxTextures = maxTextures;\n    this.vertSize = 7;\n    this.vertPerQuad = 6;\n    this.stride = this.vertSize * 4;\n    shaderGenerator.fillSamplers(this, this.maxTextures);\n}\n\nRectTileShader.prototype = Object.create(PIXI.Shader.prototype);\nRectTileShader.prototype.constructor = RectTileShader;\nRectTileShader.prototype.createVao = function (renderer, vb) {\n    var gl = renderer.gl;\n    return renderer.createVao()\n        .addIndex(this.indexBuffer)\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 4 * 4)\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 6 * 4);\n};\n\nmodule.exports = RectTileShader;\n\n},{\"./shaderGenerator\":10}],6:[function(require,module,exports){\nvar shaderGenerator = require('./shaderGenerator');\n\n\nfunction SquareTileShader(gl, maxTextures) {\n    PIXI.Shader.call(this, gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec2 aAnim;\\nattribute float aTextureId;\\nattribute float aSize;\\n\\nuniform mat3 projectionMatrix;\\nuniform vec2 samplerSize;\\nuniform vec2 animationFrame;\\nuniform float projectionScale;\\n\\nvarying vec2 vTextureCoord;\\nvarying float vSize;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition + aSize * 0.5, 1.0)).xy, 0.0, 1.0);\\n   gl_PointSize = aSize * projectionScale;\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n   vTextureId = aTextureId;\\n   vSize = aSize;\\n}\\n\",\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying float vSize;\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\nuniform sampler2D uSamplers[%count%];\\nuniform vec2 uSamplerSize[%count%];\\nuniform vec2 pointScale;\\n\\nvoid main(void){\\n   float margin = 1.0/vSize;\\n   vec2 clamped = vec2(clamp(gl_PointCoord.x, margin, 1.0 - margin), clamp(gl_PointCoord.y, margin, 1.0 - margin));\\n   vec2 textureCoord = ((clamped-0.5) * pointScale + 0.5) * vSize + vTextureCoord;\\n   vec4 color;\\n   %forloop%\\n   gl_FragColor = color;\\n}\\n\")\n    );\n    this.maxTextures = maxTextures;\n    this.vertSize = 8;\n    this.vertPerQuad = 1;\n    this.stride = this.vertSize * 4;\n    shaderGenerator.fillSamplers(this, this.maxTextures);\n}\n\nSquareTileShader.prototype = Object.create(PIXI.Shader.prototype);\nSquareTileShader.prototype.constructor = SquareTileShader;\nSquareTileShader.prototype.createVao = function (renderer, vb) {\n    var gl = renderer.gl;\n    return renderer.createVao()\n        .addIndex(this.indexBuffer)\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\n        .addAttribute(vb, this.attributes.aSize, gl.FLOAT, false, this.stride, 4 * 4)\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 5 * 4)\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 7 * 4);\n};\n\nmodule.exports = SquareTileShader;\n\n},{\"./shaderGenerator\":10}],7:[function(require,module,exports){\nvar RectTileShader = require('./RectTileShader'),\n    SquareTileShader = require('./SquareTileShader'),\n    glCore = PIXI.glCore;\n\n/*\n* Renderer for square and rectangle tiles.\n* Squares cannot be rotated, skewed.\n* For container with squares, scale.x must be equals to scale.y, matrix.a to matrix.d\n* Rectangles do not care about that.\n*\n* @class\n* @memberof PIXI.tilemap\n* @extends PIXI.ObjectRenderer\n* @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n*/\n\nfunction TileRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n    this.vbs = {};\n    this.lastTimeCheck = 0;\n    this.tileAnim = [0, 0];\n    this.maxTextures = 4;\n    this.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n}\n\nTileRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nTileRenderer.prototype.constructor = TileRenderer;\nTileRenderer.vbAutoincrement = 0;\n\nTileRenderer.prototype.onContextChange = function() {\n    var gl = this.renderer.gl;\n    var maxTextures = this.maxTextures;\n    this.rectShader = new RectTileShader(gl, maxTextures);\n    this.squareShader = new SquareTileShader(gl, maxTextures);\n    this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n    this.rectShader.indexBuffer = this.indexBuffer;\n    this.squareShader.indexBuffer = this.indexBuffer;\n    this.vbs = {};\n    this.glTextures = [];\n    this.boundSprites = [];\n    this.initBounds();\n};\n\nTileRenderer.prototype.initBounds = function() {\n    var gl = this.renderer.gl;\n    var tempCanvas = document.createElement('canvas');\n    tempCanvas.width = 2048;\n    tempCanvas.height = 2048;\n    // tempCanvas.getContext('2d').clearRect(0, 0, 2048, 2048);\n    for (var i=0;i<this.maxTextures; i++) {\n        var glt = new glCore.GLTexture(gl, 2048, 2048);\n        glt.premultiplyAlpha = true;\n        glt.upload(tempCanvas);\n        glt.enableWrapClamp();\n        glt.enableLinearScaling();\n        this.glTextures.push(glt);\n        var bs = [];\n        for (var j=0;j<4;j++) {\n            var spr = new PIXI.Sprite();\n            spr.position.x = 1024 * (j & 1);\n            spr.position.y = 1024 * (j >> 1);\n            bs.push(spr);\n        }\n        this.boundSprites.push(bs);\n    }\n};\n\nglCore.GLTexture.prototype._hackSubImage = function(sprite) {\n    this.bind();\n    var gl = this.gl;\n    var baseTex = sprite.texture.baseTexture;\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, sprite.position.x, sprite.position.y, this.format, this.type, baseTex.source);\n};\n\nTileRenderer.prototype.bindTextures = function(renderer, textures) {\n    var bounds = this.boundSprites;\n    var glts = this.glTextures;\n    var len = textures.length;\n    var maxTextures = this.maxTextures;\n    if (len >= 4 * maxTextures) {\n        return;\n    }\n    var i;\n    for (i=0;i<len;i++) {\n        var texture = textures[i];\n        renderer.bindTexture(texture);\n        if (!texture || !textures[i].valid) continue;\n        var bs = bounds[i >> 2][i & 3];\n        if (bs.texture !== texture) {\n            bs.texture = texture;\n            var glt = glts[ i >> 2 ];\n            glt._hackSubImage(bs);\n        }\n    }\n    for (i = 0; i < maxTextures; i++) {\n        glts[i].bind(i);\n    }\n    renderer._activeTextureLocation = maxTextures - 1;\n};\n\nTileRenderer.prototype.checkLeaks = function() {\n    var now = Date.now();\n    var old = now - 10000;\n    if (this.lastTimeCheck < old ||\n        this.lastTimeCheck > now) {\n        this.lastTimeCheck = now;\n        var vbs = this.vbs;\n        for (var key in vbs) {\n            if (vbs[key].lastTimeAccess < old) {\n                this.removeVb(key);\n            }\n        }\n    }\n};\n\nTileRenderer.prototype.start = function() {\n    this.renderer.state.setBlendMode( PIXI.BLEND_MODES.NORMAL );\n    //sorry, nothing\n};\n\nTileRenderer.prototype.getVb = function(id) {\n    this.checkLeaks();\n    var vb = this.vbs[id];\n    if (vb) {\n        vb.lastAccessTime = Date.now();\n        return vb;\n    }\n    return null;\n};\n\nTileRenderer.prototype.createVb = function(useSquare) {\n    var id = ++TileRenderer.vbAutoincrement;\n    var shader = this.getShader(useSquare);\n    var gl = this.renderer.gl;\n    var vb = PIXI.glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n    var stuff = {\n        id: id,\n        vb: vb,\n        vao: shader.createVao(this.renderer, vb),\n        lastTimeAccess: Date.now(),\n        useSquare: useSquare,\n        shader: shader\n    };\n    this.vbs[id] = stuff;\n    return stuff;\n};\n\nTileRenderer.prototype.removeVb = function(id) {\n    if (this.vbs[id]) {\n        this.vbs[id].vb.destroy();\n        this.vbs[id].vao.destroy();\n        delete this.vbs[id];\n    }\n};\n\nTileRenderer.prototype.getShader = function(useSquare) {\n    return useSquare ? this.squareShader : this.rectShader;\n};\n\nTileRenderer.prototype.destroy = function () {\n    PIXI.ObjectRenderer.prototype.destroy.call(this);\n    this.rectShader.destroy();\n    this.squareShader.destroy();\n    this.rectShader = null;\n    this.squareShader = null;\n};\n\nPIXI.WebGLRenderer.registerPlugin('tile', TileRenderer);\n\nmodule.exports = TileRenderer;\n\n},{\"./RectTileShader\":5,\"./SquareTileShader\":6}],8:[function(require,module,exports){\nfunction ZLayer() {\n    this.initialize.apply(this, arguments);\n}\n\nZLayer.prototype = Object.create(PIXI.Container.prototype);\nZLayer.prototype.initialize = function(tilemap, zIndex) {\n    PIXI.Container.apply(this, arguments);\n    this.tilemap = tilemap;\n    this.z = zIndex;\n};\n\nZLayer.prototype.clear = function() {\n    var layers = this.children;\n    for (var i=0; i<layers.length; i++)\n        layers[i].clear();\n    this._previousLayers = 0;\n};\n\nZLayer.prototype.cacheIfDirty = function() {\n    var tilemap = this.tilemap;\n    var layers = this.children;\n    var modified = this._previousLayers != layers.length;\n    this._previousLayers = layers.length;\n    var buf = this.canvasBuffer;\n    var tempRender = this._tempRender;\n    if (!buf) {\n        buf = this.canvasBuffer = document.createElement('canvas');\n        tempRender = this._tempRender = new PIXI.CanvasRenderer(100, 100, { view: buf });\n        tempRender.context = tempRender.rootContext;\n        tempRender.dontUseTransform = true;\n    }\n    if (buf.width != tilemap._layerWidth ||\n        buf.height != tilemap._layerHeight) {\n        buf.width = tilemap._layerWidth;\n        buf.height = tilemap._layerHeight;\n        modified = true;\n    }\n    var i;\n    if (!modified) {\n        for (i=0;i<layers.length;i++) {\n            if (layers[i].isModified(this._lastAnimationFrame != tilemap.animationFrame)) {\n                modified = true;\n                break;\n            }\n        }\n    }\n    this._lastAnimationFrame = tilemap.animationFrame;\n    if (modified) {\n        if (tilemap._hackRenderer) {\n            tilemap._hackRenderer(tempRender);\n        }\n        tempRender.context.clearRect(0, 0, buf.width, buf.height);\n        for (i=0;i<layers.length;i++) {\n            layers[i].clearModify();\n            layers[i].renderCanvas(tempRender);\n        }\n    }\n    this.layerTransform = this.worldTransform;\n    for (i=0;i<layers.length;i++) {\n        this.layerTransform = layers[i].worldTransform;\n        break;\n    }\n};\n\nZLayer.prototype.renderCanvas = function(renderer) {\n    this.cacheIfDirty();\n    var wt = this.layerTransform;\n    renderer.context.setTransform(\n        wt.a,\n        wt.b,\n        wt.c,\n        wt.d,\n        wt.tx * renderer.resolution,\n        wt.ty * renderer.resolution\n    );\n    var tilemap = this.tilemap;\n    renderer.context.drawImage(this.canvasBuffer, 0, 0);\n};\n\nmodule.exports = ZLayer;\n\n},{}],9:[function(require,module,exports){\nPIXI.tilemap = {\n    ZLayer: require('./ZLayer'),\n    GraphicsLayer: require('./GraphicsLayer'),\n    RectTileLayer: require('./RectTileLayer'),\n    CompositeRectTileLayer: require('./CompositeRectTileLayer'),\n    CanvasTileRenderer: require('./CanvasTileRenderer'),\n    TileRenderer: require('./TileRenderer')\n};\n\nmodule.exports = PIXI.tilemap;\n\n},{\"./CanvasTileRenderer\":1,\"./CompositeRectTileLayer\":2,\"./GraphicsLayer\":3,\"./RectTileLayer\":4,\"./TileRenderer\":7,\"./ZLayer\":8}],10:[function(require,module,exports){\nvar shaderGenerator = {\n    fillSamplers: function(shader, maxTextures) {\n        var sampleValues = [];\n        for (var i = 0; i < maxTextures; i++)\n        {\n            sampleValues[i] = i;\n        }\n        shader.bind();\n        shader.uniforms.uSamplers = sampleValues;\n\n        var samplerSize = [];\n        for (i = 0; i < maxTextures; i++) {\n            samplerSize.push(1.0 / 2048);\n            samplerSize.push(1.0 / 2048);\n        }\n        shader.uniforms.uSamplerSize = samplerSize;\n    },\n    generateFragmentSrc: function(maxTextures, fragmentSrc) {\n        return fragmentSrc.replace(/%count%/gi, maxTextures)\n            .replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n    },\n    generateSampleSrc: function(maxTextures) {\n        var src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        src += 'if(vTextureId <= -1.0) {';\n        src += '\\n\\tcolor = shadowColor;';\n        src += '\\n}';\n\n        for (var i = 0; i < maxTextures; i++)\n        {\n            src += '\\nelse ';\n\n            if(i < maxTextures-1)\n            {\n                src += 'if(vTextureId == ' + i + '.0)';\n            }\n\n            src += '\\n{';\n            src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n};\n\nmodule.exports = shaderGenerator;\n\n},{}]},{},[9])\n\n","var RectTileLayer = require('./RectTileLayer');\n\nfunction CompositeRectTileLayer() {\n    PIXI.Container.apply(this, arguments);\n    this.initialize.apply(this, arguments);\n}\n\nCompositeRectTileLayer.prototype = Object.create(PIXI.Container.prototype);\nCompositeRectTileLayer.prototype.constructor = RectTileLayer;\nCompositeRectTileLayer.prototype.updateTransform = CompositeRectTileLayer.prototype.displayObjectUpdateTransform;\n\n//can be initialized multiple times\nCompositeRectTileLayer.prototype.initialize = function(zIndex, bitmaps, useSquare) {\n    this.z = this.zIndex = zIndex;\n    this.useSquare = useSquare;\n    this.shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n    if (bitmaps) {\n        this.setBitmaps(bitmaps);\n    }\n};\n\nCompositeRectTileLayer.prototype.setBitmaps = function(bitmaps) {\n    this.removeChildren();\n    this.addChild(new RectTileLayer(this.zIndex, bitmaps));\n    this.modificationMarker = 0;\n};\n\nCompositeRectTileLayer.prototype.clear = function () {\n    for (var i=0;i<this.children.length;i++)\n        this.children[i].clear();\n    this.modificationMarker = 0;\n};\n\nCompositeRectTileLayer.prototype.addRect = function (num, u, v, x, y, tileWidth, tileHeight) {\n    if (this.children[num] && this.children[num].textures)\n        this.children[num].addRect(0, u, v, x, y, tileWidth, tileHeight);\n};\n\n/**\n * \"hello world!\" of pixi-tilemap library. Pass it texture and it will be added\n * @param texture\n * @param x\n * @param y\n * @returns {boolean}\n */\nCompositeRectTileLayer.prototype.addFrame = function (texture, x, y) {\n    if (typeof texture === \"string\") {\n        texture = PIXI.Texture.fromImage(texture);\n    }\n    var children = this.children;\n    var layer = null, ind = 0;\n    for (var i=0;i<children.length; i++) {\n        var tex = children[i].textures;\n        for (var j=0;j < tex.length;j++) {\n            if (tex[j].baseTexture == texture.baseTexture) {\n                layer = children[i];\n                ind = j;\n                break;\n            }\n        }\n        if (layer) {\n            break;\n        }\n    }\n    if (!layer) {\n        for (i=0;i<children.length;i++) {\n            var child = children[i];\n            if (child.textures.length < 16) {\n                layer = child;\n                ind = child.textures.length;\n                child.textures.push(texture);\n            }\n        }\n        if (!layer) {\n            children.push(layer = new RectTileLayer(this.zIndex, texture));\n            ind = 0;\n        }\n    }\n    layer.addRect(ind, texture.frame.x, texture.frame.y, x, y, texture.frame.width, texture.frame.height);\n    return true;\n};\n\nCompositeRectTileLayer.prototype.renderCanvas = function (renderer) {\n    if (!renderer.dontUseTransform) {\n        var wt = this.worldTransform;\n        renderer.context.setTransform(\n            wt.a,\n            wt.b,\n            wt.c,\n            wt.d,\n            wt.tx * renderer.resolution,\n            wt.ty * renderer.resolution\n        );\n    }\n    var layers = this.children;\n    for (var i = 0; i < layers.length; i++)\n        layers[i].renderCanvas(renderer);\n};\n\n\nCompositeRectTileLayer.prototype.renderWebGL = function(renderer) {\n    var gl = renderer.gl;\n    var shader = renderer.plugins.tile.getShader(this.useSquare);\n    renderer.setObjectRenderer(renderer.plugins.tile);\n    renderer.bindShader(shader);\n    //TODO: dont create new array, please\n    this._globalMat = this._globalMat || new PIXI.Matrix();\n    renderer._activeRenderTarget.projectionMatrix.copy(this._globalMat).append(this.worldTransform);\n    shader.uniforms.projectionMatrix = this._globalMat.toArray(true);\n    shader.uniforms.shadowColor = this.shadowColor;\n    if (this.useSquare) {\n        var tempScale = this._tempScale = (this._tempScale || [0, 0]);\n        tempScale[0] = this._globalMat.a >= 0?1:-1;\n        tempScale[1] = this._globalMat.d < 0?1:-1;\n        var ps = shader.uniforms.pointScale = tempScale;\n        shader.uniforms.projectionScale = Math.abs(this.worldTransform.a) * renderer.resolution;\n    }\n    var af = shader.uniforms.animationFrame = renderer.plugins.tile.tileAnim;\n    //shader.syncUniform(shader.uniforms.animationFrame);\n    var layers = this.children;\n    for (var i = 0; i < layers.length; i++)\n        layers[i].renderWebGL(renderer, this.useSquare);\n};\n\n\nCompositeRectTileLayer.prototype.isModified = function(anim) {\n    var layers = this.children;\n    if (this.modificationMarker != layers.length) {\n        return true;\n    }\n    for (var i=0;i<layers.length;i++) {\n        if (layers[i].modificationMarker != layers[i].pointsBuf.length ||\n            anim && layers[i].hasAnim) {\n            return true;\n        }\n    }\n    return false;\n};\n\nCompositeRectTileLayer.prototype.clearModify = function() {\n    var layers = this.children;\n    this.modificationMarker = layers.length;\n    for (var i = 0; i < layers.length; i++) {\n        layers[i].modificationMarker = layers[i].pointsBuf.length;\n    }\n};\n\nmodule.exports = CompositeRectTileLayer;\n","function GraphicsLayer(zIndex) {\n    PIXI.Graphics.apply(this, arguments);\n    this.z = this.zIndex = zIndex;\n}\n\nGraphicsLayer.prototype = Object.create(PIXI.Graphics.prototype);\nGraphicsLayer.prototype.constructor = GraphicsLayer;\nGraphicsLayer.prototype.renderCanvas = function (renderer) {\n    var wt = null;\n    if (renderer.dontUseTransform) {\n        wt = this.transform.worldTransform;\n        this.transform.worldTransform = PIXI.Matrix.IDENTITY;\n    }\n    renderer.plugins.graphics.render(this);\n    if (renderer.dontUseTransform) {\n        this.transform.worldTransform = wt;\n    }\n    renderer.context.globalAlpha = 1.0;\n};\nGraphicsLayer.prototype.renderWebGL = function(renderer) {\n    if (!this._webGL[renderer.gl.id])\n        this.dirty = true;\n    PIXI.Graphics.prototype.renderWebGL.call(this, renderer);\n};\n\nGraphicsLayer.prototype.isModified = function(anim) {\n    return false;\n};\n\nGraphicsLayer.prototype.clearModify = function() {\n};\n\nmodule.exports = GraphicsLayer;\n","function RectTileLayer(zIndex, texture) {\n    PIXI.DisplayObject.apply(this, arguments);\n    this.initialize.apply(this, arguments);\n}\n\nRectTileLayer.prototype = Object.create(PIXI.DisplayObject.prototype);\nRectTileLayer.prototype.constructor = RectTileLayer;\n\nRectTileLayer.prototype.initialize = function(zIndex, textures) {\n    if (!textures) {\n        textures = [];\n    } else if (!(textures instanceof Array) && textures.baseTexture) {\n        textures = [textures];\n    }\n    this.textures = textures;\n    this.z = this.zIndex = zIndex;\n    this.pointsBuf = [];\n    this.visible = false;\n    this._tempSize = new Float32Array([0, 0]);\n    this._tempTexSize = 1;\n};\n\nRectTileLayer.prototype.clear = function () {\n    this.pointsBuf.length = 0;\n    this.modificationMarker = 0;\n    this.hasAnim = false;\n};\n\nRectTileLayer.prototype.renderCanvas = function (renderer) {\n    if (this.textures.length === 0) return;\n    var points = this.pointsBuf;\n    renderer.context.fillStyle = '#000000';\n    for (var i = 0, n = points.length; i < n; i += 9) {\n        var x1 = points[i], y1 = points[i+1];\n        var x2 = points[i+2], y2 = points[i+3];\n        var w = points[i+4];\n        var h = points[i+5];\n        x1 += points[i+6] * renderer.plugins.tile.tileAnim[0];\n        y1 += points[i+7] * renderer.plugins.tile.tileAnim[1];\n        var textureId = points[i+8];\n        if (textureId >= 0) {\n            renderer.context.drawImage(this.textures[textureId].baseTexture.source, x1, y1, w, h, x2, y2, w, h);\n        } else {\n            renderer.context.globalAlpha = 0.5;\n            renderer.context.fillRect(x2, y2, w, h);\n            renderer.context.globalAlpha = 1;\n        }\n    }\n};\n\nRectTileLayer.prototype.addRect = function (textureId, u, v, x, y, tileWidth, tileHeight, animX, animY) {\n    var pb = this.pointsBuf;\n    this.hasAnim = this.hasAnim || animX > 0 || animY > 0;\n    if (tileWidth == tileHeight) {\n        pb.push(u);\n        pb.push(v);\n        pb.push(x);\n        pb.push(y);\n        pb.push(tileWidth);\n        pb.push(tileHeight);\n        pb.push(animX | 0);\n        pb.push(animY | 0);\n        pb.push(textureId);\n    } else {\n        var i;\n        if (tileWidth % tileHeight === 0) {\n            //horizontal line on squares\n            for (i=0;i<tileWidth/tileHeight;i++) {\n                pb.push(u + i * tileHeight);\n                pb.push(v);\n                pb.push(x + i * tileHeight);\n                pb.push(y);\n                pb.push(tileHeight);\n                pb.push(tileHeight);\n                pb.push(animX | 0);\n                pb.push(animY | 0);\n                pb.push(textureId);\n            }\n        } else if (tileHeight % tileWidth === 0) {\n            //vertical line on squares\n            for (i=0;i<tileHeight/tileWidth;i++) {\n                pb.push(u);\n                pb.push(v + i * tileWidth);\n                pb.push(x);\n                pb.push(y + i * tileWidth);\n                pb.push(tileWidth);\n                pb.push(tileWidth);\n                pb.push(animX | 0);\n                pb.push(animY | 0);\n                pb.push(textureId);\n            }\n        } else {\n            //ok, ok, lets use rectangle. but its not working with square shader yet\n            pb.push(u);\n            pb.push(v);\n            pb.push(x);\n            pb.push(y);\n            pb.push(tileWidth);\n            pb.push(tileHeight);\n            pb.push(animX | 0);\n            pb.push(animY | 0);\n            pb.push(textureId);\n        }\n    }\n};\n\nRectTileLayer.prototype.renderWebGL = function(renderer, useSquare) {\n    var points = this.pointsBuf;\n    if (points.length === 0) return;\n\n    var tile = renderer.plugins.tile;\n    var gl = renderer.gl;\n    var shader = tile.getShader(useSquare);\n    var textures = this.textures;\n    if (textures.length === 0) return;\n    var len = textures.length;\n    if (this._tempTexSize < shader.maxTextures) {\n        this._tempTexSize = shader.maxTextures;\n        this._tempSize = new Float32Array(2*shader.maxTextures);\n    }\n    // var samplerSize = this._tempSize;\n    for (var i=0;i<len;i++) {\n        if (!textures[i] || !textures[i].valid) return;\n        var texture = textures[i].baseTexture;\n        // samplerSize[i * 2] = 1.0 / texture.width;\n        // samplerSize[i * 2 + 1] = 1.0 / texture.height;\n    }\n    tile.bindTextures(renderer, textures);\n    // shader.uniforms.uSamplerSize = samplerSize;\n    //lost context! recover!\n    var vb = tile.getVb(this.vbId);\n    if (!vb) {\n        vb = tile.createVb(useSquare);\n        this.vbId = vb.id;\n        this.vbBuffer = null;\n        this.modificationMarker = 0;\n    }\n    var vao = vb.vao.bind();\n    vb = vb.vb;\n    //if layer was changed, re-upload vertices\n    vb.bind();\n    var vertices = points.length / 9 * shader.vertPerQuad;\n    if (this.modificationMarker != vertices) {\n        this.modificationMarker = vertices;\n        var vs = shader.stride * vertices;\n        if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n            //!@#$ happens, need resize\n            var bk = shader.stride;\n            while (bk < vs) {\n                bk *= 2;\n            }\n            this.vbBuffer = new ArrayBuffer(bk);\n            this.vbArray = new Float32Array(this.vbBuffer);\n            this.vbInts = new Uint32Array(this.vbBuffer);\n            vb.upload(this.vbBuffer, 0, true);\n        }\n\n        var arr = this.vbArray, ints = this.vbInts;\n        //upload vertices!\n        var sz = 0;\n        //var tint = 0xffffffff;\n        var textureId, shiftU, shiftV;\n        if (useSquare) {\n            for (i = 0; i < points.length; i += 9) {\n                textureId = (points[i+8] >> 2);\n                shiftU = 1024 * (points[i+8] & 1);\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\n                arr[sz++] = points[i + 2];\n                arr[sz++] = points[i + 3];\n                arr[sz++] = points[i + 0] + shiftU;\n                arr[sz++] = points[i + 1] + shiftV;\n                arr[sz++] = points[i + 4];\n                arr[sz++] = points[i + 6];\n                arr[sz++] = points[i + 7];\n                arr[sz++] = textureId;\n            }\n        } else {\n            //var tint = 0xffffffff;\n            var tint = -1;\n            for (i = 0;i<points.length;i += 9) {\n                textureId = (points[i+8] >> 2);\n                shiftU = 1024 * (points[i+8] & 1);\n                shiftV = 1024 * ((points[i+8] >> 1) & 1);\n                var x = points[i+2], y = points[i+3];\n                var w = points[i+4], h = points[i+5];\n                var u = points[i] + shiftU, v = points[i+1] + shiftV;\n                var animX = points[i+6], animY = points[i+7];\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y;\n                arr[sz++] = u + w;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u + w;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y;\n                arr[sz++] = u;\n                arr[sz++] = v;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x + w;\n                arr[sz++] = y + h;\n                arr[sz++] = u + w;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n                arr[sz++] = x;\n                arr[sz++] = y + h;\n                arr[sz++] = u;\n                arr[sz++] = v + h;\n                arr[sz++] = animX;\n                arr[sz++] = animY;\n                arr[sz++] = textureId;\n            }\n        }\n        // if (vs > this.vbArray.length/2 ) {\n        vb.upload(arr, 0, true);\n        // } else {\n        //     var view = arr.subarray(0, vs);\n        //     vb.upload(view, 0);\n        // }\n    }\n    if (useSquare)\n        gl.drawArrays(gl.POINTS, 0, vertices);\n    else\n        gl.drawArrays(gl.TRIANGLES, 0, vertices);\n};\n\nmodule.exports = RectTileLayer;\n","var shaderGenerator = require('./shaderGenerator');\n\nfunction RectTileShader(gl, maxTextures)\n{\n    PIXI.Shader.call(this, gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec2 aAnim;\\nattribute float aTextureId;\\n\\nuniform mat3 projectionMatrix;\\nuniform vec2 animationFrame;\\n\\nvarying vec2 vTextureCoord;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n   vTextureId = aTextureId;\\n}\\n\",\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying float vTextureId;\\nuniform vec4 shadowColor;\\nuniform sampler2D uSamplers[%count%];\\nuniform vec2 uSamplerSize[%count%];\\n\\nvoid main(void){\\n   vec2 textureCoord = vTextureCoord;\\n   vec4 color;\\n   %forloop%\\n   gl_FragColor = color;\\n}\\n\")\n    );\n    this.maxTextures = maxTextures;\n    this.vertSize = 7;\n    this.vertPerQuad = 6;\n    this.stride = this.vertSize * 4;\n    shaderGenerator.fillSamplers(this, this.maxTextures);\n}\n\nRectTileShader.prototype = Object.create(PIXI.Shader.prototype);\nRectTileShader.prototype.constructor = RectTileShader;\nRectTileShader.prototype.createVao = function (renderer, vb) {\n    var gl = renderer.gl;\n    return renderer.createVao()\n        .addIndex(this.indexBuffer)\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 4 * 4)\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 6 * 4);\n};\n\nmodule.exports = RectTileShader;\n","var shaderGenerator = require('./shaderGenerator');\n\n\nfunction SquareTileShader(gl, maxTextures) {\n    PIXI.Shader.call(this, gl,\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec2 aAnim;\\nattribute float aTextureId;\\nattribute float aSize;\\n\\nuniform mat3 projectionMatrix;\\nuniform vec2 samplerSize;\\nuniform vec2 animationFrame;\\nuniform float projectionScale;\\n\\nvarying vec2 vTextureCoord;\\nvarying float vSize;\\nvarying float vTextureId;\\n\\nvoid main(void){\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition + aSize * 0.5, 1.0)).xy, 0.0, 1.0);\\n   gl_PointSize = aSize * projectionScale;\\n   vTextureCoord = aTextureCoord + aAnim * animationFrame;\\n   vTextureId = aTextureId;\\n   vSize = aSize;\\n}\\n\",\n        shaderGenerator.generateFragmentSrc(maxTextures, \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying float vSize;\\nvarying float vTextureId;\\n\\nuniform vec4 shadowColor;\\nuniform sampler2D uSamplers[%count%];\\nuniform vec2 uSamplerSize[%count%];\\nuniform vec2 pointScale;\\n\\nvoid main(void){\\n   float margin = 1.0/vSize;\\n   vec2 clamped = vec2(clamp(gl_PointCoord.x, margin, 1.0 - margin), clamp(gl_PointCoord.y, margin, 1.0 - margin));\\n   vec2 textureCoord = ((clamped-0.5) * pointScale + 0.5) * vSize + vTextureCoord;\\n   vec4 color;\\n   %forloop%\\n   gl_FragColor = color;\\n}\\n\")\n    );\n    this.maxTextures = maxTextures;\n    this.vertSize = 8;\n    this.vertPerQuad = 1;\n    this.stride = this.vertSize * 4;\n    shaderGenerator.fillSamplers(this, this.maxTextures);\n}\n\nSquareTileShader.prototype = Object.create(PIXI.Shader.prototype);\nSquareTileShader.prototype.constructor = SquareTileShader;\nSquareTileShader.prototype.createVao = function (renderer, vb) {\n    var gl = renderer.gl;\n    return renderer.createVao()\n        .addIndex(this.indexBuffer)\n        .addAttribute(vb, this.attributes.aVertexPosition, gl.FLOAT, false, this.stride, 0)\n        .addAttribute(vb, this.attributes.aTextureCoord, gl.FLOAT, false, this.stride, 2 * 4)\n        .addAttribute(vb, this.attributes.aSize, gl.FLOAT, false, this.stride, 4 * 4)\n        .addAttribute(vb, this.attributes.aAnim, gl.FLOAT, false, this.stride, 5 * 4)\n        .addAttribute(vb, this.attributes.aTextureId, gl.FLOAT, false, this.stride, 7 * 4);\n};\n\nmodule.exports = SquareTileShader;\n","var RectTileShader = require('./RectTileShader'),\n    SquareTileShader = require('./SquareTileShader'),\n    glCore = PIXI.glCore;\n\n/*\n* Renderer for square and rectangle tiles.\n* Squares cannot be rotated, skewed.\n* For container with squares, scale.x must be equals to scale.y, matrix.a to matrix.d\n* Rectangles do not care about that.\n*\n* @class\n* @memberof PIXI.tilemap\n* @extends PIXI.ObjectRenderer\n* @param renderer {PIXI.WebGLRenderer} The renderer this sprite batch works for.\n*/\n\nfunction TileRenderer(renderer) {\n    PIXI.ObjectRenderer.call(this, renderer);\n    this.vbs = {};\n    this.lastTimeCheck = 0;\n    this.tileAnim = [0, 0];\n    this.maxTextures = 4;\n    this.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n}\n\nTileRenderer.prototype = Object.create(PIXI.ObjectRenderer.prototype);\nTileRenderer.prototype.constructor = TileRenderer;\nTileRenderer.vbAutoincrement = 0;\n\nTileRenderer.prototype.onContextChange = function() {\n    var gl = this.renderer.gl;\n    var maxTextures = this.maxTextures;\n    this.rectShader = new RectTileShader(gl, maxTextures);\n    this.squareShader = new SquareTileShader(gl, maxTextures);\n    this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n    this.rectShader.indexBuffer = this.indexBuffer;\n    this.squareShader.indexBuffer = this.indexBuffer;\n    this.vbs = {};\n    this.glTextures = [];\n    this.boundSprites = [];\n    this.initBounds();\n};\n\nTileRenderer.prototype.initBounds = function() {\n    var gl = this.renderer.gl;\n    var tempCanvas = document.createElement('canvas');\n    tempCanvas.width = 2048;\n    tempCanvas.height = 2048;\n    // tempCanvas.getContext('2d').clearRect(0, 0, 2048, 2048);\n    for (var i=0;i<this.maxTextures; i++) {\n        var glt = new glCore.GLTexture(gl, 2048, 2048);\n        glt.premultiplyAlpha = true;\n        glt.upload(tempCanvas);\n        glt.enableWrapClamp();\n        glt.enableLinearScaling();\n        this.glTextures.push(glt);\n        var bs = [];\n        for (var j=0;j<4;j++) {\n            var spr = new PIXI.Sprite();\n            spr.position.x = 1024 * (j & 1);\n            spr.position.y = 1024 * (j >> 1);\n            bs.push(spr);\n        }\n        this.boundSprites.push(bs);\n    }\n};\n\nglCore.GLTexture.prototype._hackSubImage = function(sprite) {\n    this.bind();\n    var gl = this.gl;\n    var baseTex = sprite.texture.baseTexture;\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, sprite.position.x, sprite.position.y, this.format, this.type, baseTex.source);\n};\n\nTileRenderer.prototype.bindTextures = function(renderer, textures) {\n    var bounds = this.boundSprites;\n    var glts = this.glTextures;\n    var len = textures.length;\n    var maxTextures = this.maxTextures;\n    if (len >= 4 * maxTextures) {\n        return;\n    }\n    var i;\n    for (i=0;i<len;i++) {\n        var texture = textures[i];\n        renderer.bindTexture(texture);\n        if (!texture || !textures[i].valid) continue;\n        var bs = bounds[i >> 2][i & 3];\n        if (bs.texture !== texture) {\n            bs.texture = texture;\n            var glt = glts[ i >> 2 ];\n            glt._hackSubImage(bs);\n        }\n    }\n    for (i = 0; i < maxTextures; i++) {\n        glts[i].bind(i);\n    }\n    renderer._activeTextureLocation = maxTextures - 1;\n};\n\nTileRenderer.prototype.checkLeaks = function() {\n    var now = Date.now();\n    var old = now - 10000;\n    if (this.lastTimeCheck < old ||\n        this.lastTimeCheck > now) {\n        this.lastTimeCheck = now;\n        var vbs = this.vbs;\n        for (var key in vbs) {\n            if (vbs[key].lastTimeAccess < old) {\n                this.removeVb(key);\n            }\n        }\n    }\n};\n\nTileRenderer.prototype.start = function() {\n    this.renderer.state.setBlendMode( PIXI.BLEND_MODES.NORMAL );\n    //sorry, nothing\n};\n\nTileRenderer.prototype.getVb = function(id) {\n    this.checkLeaks();\n    var vb = this.vbs[id];\n    if (vb) {\n        vb.lastAccessTime = Date.now();\n        return vb;\n    }\n    return null;\n};\n\nTileRenderer.prototype.createVb = function(useSquare) {\n    var id = ++TileRenderer.vbAutoincrement;\n    var shader = this.getShader(useSquare);\n    var gl = this.renderer.gl;\n    var vb = PIXI.glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n    var stuff = {\n        id: id,\n        vb: vb,\n        vao: shader.createVao(this.renderer, vb),\n        lastTimeAccess: Date.now(),\n        useSquare: useSquare,\n        shader: shader\n    };\n    this.vbs[id] = stuff;\n    return stuff;\n};\n\nTileRenderer.prototype.removeVb = function(id) {\n    if (this.vbs[id]) {\n        this.vbs[id].vb.destroy();\n        this.vbs[id].vao.destroy();\n        delete this.vbs[id];\n    }\n};\n\nTileRenderer.prototype.getShader = function(useSquare) {\n    return useSquare ? this.squareShader : this.rectShader;\n};\n\nTileRenderer.prototype.destroy = function () {\n    PIXI.ObjectRenderer.prototype.destroy.call(this);\n    this.rectShader.destroy();\n    this.squareShader.destroy();\n    this.rectShader = null;\n    this.squareShader = null;\n};\n\nPIXI.WebGLRenderer.registerPlugin('tile', TileRenderer);\n\nmodule.exports = TileRenderer;\n","function ZLayer() {\n    this.initialize.apply(this, arguments);\n}\n\nZLayer.prototype = Object.create(PIXI.Container.prototype);\nZLayer.prototype.initialize = function(tilemap, zIndex) {\n    PIXI.Container.apply(this, arguments);\n    this.tilemap = tilemap;\n    this.z = zIndex;\n};\n\nZLayer.prototype.clear = function() {\n    var layers = this.children;\n    for (var i=0; i<layers.length; i++)\n        layers[i].clear();\n    this._previousLayers = 0;\n};\n\nZLayer.prototype.cacheIfDirty = function() {\n    var tilemap = this.tilemap;\n    var layers = this.children;\n    var modified = this._previousLayers != layers.length;\n    this._previousLayers = layers.length;\n    var buf = this.canvasBuffer;\n    var tempRender = this._tempRender;\n    if (!buf) {\n        buf = this.canvasBuffer = document.createElement('canvas');\n        tempRender = this._tempRender = new PIXI.CanvasRenderer(100, 100, { view: buf });\n        tempRender.context = tempRender.rootContext;\n        tempRender.dontUseTransform = true;\n    }\n    if (buf.width != tilemap._layerWidth ||\n        buf.height != tilemap._layerHeight) {\n        buf.width = tilemap._layerWidth;\n        buf.height = tilemap._layerHeight;\n        modified = true;\n    }\n    var i;\n    if (!modified) {\n        for (i=0;i<layers.length;i++) {\n            if (layers[i].isModified(this._lastAnimationFrame != tilemap.animationFrame)) {\n                modified = true;\n                break;\n            }\n        }\n    }\n    this._lastAnimationFrame = tilemap.animationFrame;\n    if (modified) {\n        if (tilemap._hackRenderer) {\n            tilemap._hackRenderer(tempRender);\n        }\n        tempRender.context.clearRect(0, 0, buf.width, buf.height);\n        for (i=0;i<layers.length;i++) {\n            layers[i].clearModify();\n            layers[i].renderCanvas(tempRender);\n        }\n    }\n    this.layerTransform = this.worldTransform;\n    for (i=0;i<layers.length;i++) {\n        this.layerTransform = layers[i].worldTransform;\n        break;\n    }\n};\n\nZLayer.prototype.renderCanvas = function(renderer) {\n    this.cacheIfDirty();\n    var wt = this.layerTransform;\n    renderer.context.setTransform(\n        wt.a,\n        wt.b,\n        wt.c,\n        wt.d,\n        wt.tx * renderer.resolution,\n        wt.ty * renderer.resolution\n    );\n    var tilemap = this.tilemap;\n    renderer.context.drawImage(this.canvasBuffer, 0, 0);\n};\n\nmodule.exports = ZLayer;\n","PIXI.tilemap = {\n    ZLayer: require('./ZLayer'),\n    GraphicsLayer: require('./GraphicsLayer'),\n    RectTileLayer: require('./RectTileLayer'),\n    CompositeRectTileLayer: require('./CompositeRectTileLayer'),\n    CanvasTileRenderer: require('./CanvasTileRenderer'),\n    TileRenderer: require('./TileRenderer')\n};\n\nmodule.exports = PIXI.tilemap;\n","var shaderGenerator = {\n    fillSamplers: function(shader, maxTextures) {\n        var sampleValues = [];\n        for (var i = 0; i < maxTextures; i++)\n        {\n            sampleValues[i] = i;\n        }\n        shader.bind();\n        shader.uniforms.uSamplers = sampleValues;\n\n        var samplerSize = [];\n        for (i = 0; i < maxTextures; i++) {\n            samplerSize.push(1.0 / 2048);\n            samplerSize.push(1.0 / 2048);\n        }\n        shader.uniforms.uSamplerSize = samplerSize;\n    },\n    generateFragmentSrc: function(maxTextures, fragmentSrc) {\n        return fragmentSrc.replace(/%count%/gi, maxTextures)\n            .replace(/%forloop%/gi, this.generateSampleSrc(maxTextures));\n    },\n    generateSampleSrc: function(maxTextures) {\n        var src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        src += 'if(vTextureId <= -1.0) {';\n        src += '\\n\\tcolor = shadowColor;';\n        src += '\\n}';\n\n        for (var i = 0; i < maxTextures; i++)\n        {\n            src += '\\nelse ';\n\n            if(i < maxTextures-1)\n            {\n                src += 'if(vTextureId == ' + i + '.0)';\n            }\n\n            src += '\\n{';\n            src += '\\n\\tcolor = texture2D(uSamplers['+i+'], textureCoord * uSamplerSize['+i+']);';\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n};\n\nmodule.exports = shaderGenerator;\n"],"sourceRoot":"./"}